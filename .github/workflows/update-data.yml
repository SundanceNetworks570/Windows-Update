name: Build MSRC updates JSON (daily)

on:
  # Manual run with adjustable lookback
  workflow_dispatch:
    inputs:
      days_back:
        description: "Days back to include (keep small to avoid throttling)"
        default: "7"
        required: false
        type: string
  # Daily at 09:09 UTC (adjust as needed)
  schedule:
    - cron: "9 9 * * *"

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest
    timeout-minutes: 12

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install requests

      - name: Build data.json (SUG v2; API key support + throttling backoff)
        env:
          DAYS_BACK: ${{ inputs.days_back }}
          MSRC_API_KEY: ${{ secrets.MSRC_API_KEY }}   # Add in repo settings for best reliability
        shell: bash
        run: |
          python - << 'PY'
          import os, json, time, random
          from datetime import datetime, timedelta, timezone
          import requests

          # ---------------------- Config ----------------------
          days_back = int(os.getenv("DAYS_BACK") or "7")
          top_n = 100                          # keep small to reduce throttling
          timeout_sec = 25
          max_attempts = 6
          backoffs = [10, 20, 40, 60, 90, 120] # total ~5 min
          ua = "Sundance-WindowsUpdateBot/1.0 (+ops@sundancenetworks.com)"
          # ----------------------------------------------------

          now = datetime.now(timezone.utc)
          start = now - timedelta(days=days_back)
          def iso(dt): return dt.replace(microsecond=0).isoformat().replace("+00:00","Z")

          url = (
            "https://api.msrc.microsoft.com/sug/v2.0/updates"
            f"?$select=title,cveIds,releaseDate,lastModifiedDate,productFamily"
            f"&$filter=releaseDate ge {iso(start)} and releaseDate le {iso(now)}"
            f"&$orderby=releaseDate desc"
            f"&$top={top_n}"
          )

          headers = {
            "Accept": "application/json",
            "User-Agent": ua,
          }
          api_key = os.getenv("MSRC_API_KEY")
          if api_key:
            headers["api-key"] = api_key

          def fetch_with_retries(u):
            for i in range(max_attempts):
              try:
                r = requests.get(u, headers=headers, timeout=timeout_sec)
                if r.status_code in (429, 499, 500, 502, 503, 504, 999):
                  delay = backoffs[i] if i < len(backoffs) else backoffs[-1]
                  print(f"⚠️  MSRC throttle/temp error {r.status_code}; retrying in {delay}s… ({i+1}/{max_attempts})",
                        flush=True)
                  time.sleep(delay + random.uniform(0, 1.5))
                  continue
                r.raise_for_status()
                try:
                  return r.json()
                except Exception:
                  delay = backoffs[i] if i < len(backoffs) else backoffs[-1]
                  print(f"⚠️  Non-JSON response; retrying in {delay}s… ({i+1}/{max_attempts})", flush=True)
                  time.sleep(delay + random.uniform(0, 1.5))
                  continue
              except requests.RequestException as e:
                delay = backoffs[i] if i < len(backoffs) else backoffs[-1]
                print(f"⚠️  Network/API error: {e}; retrying in {delay}s… ({i+1}/{max_attempts})", flush=True)
                time.sleep(delay + random.uniform(0, 1.5))
            print("❌ All retries exhausted or invalid JSON. Returning empty set.", flush=True)
            return {"value": []}

          raw = fetch_with_retries(url)
          items = raw.get("value", [])

          # Normalize + strict window filter (server-side filter is already applied)
          def parse_dt(s):
            try:
              return datetime.fromisoformat(s.replace("Z","+00:00")).astimezone(timezone.utc)
            except Exception:
              return None

          out = []
          for it in items:
            rel = parse_dt(it.get("releaseDate") or "")
            if not rel:
              continue
            if not (start <= rel <= now):
              continue
            out.append({
              "title": it.get("title"),
              "cveIds": it.get("cveIds") or [],
              "releaseDate": rel.strftime("%Y-%m-%dT%H:%M:%SZ"),
              "lastModifiedDate": it.get("lastModifiedDate"),
              "productFamily": it.get("productFamily"),
            })

          # Sort newest first
          out.sort(key=lambda x: x["releaseDate"], reverse=True)

          # If nothing new (throttled, etc.), keep existing file (don’t overwrite with empty)
          if not out:
            print("ℹ️  No valid entries collected; preserving existing data.json.", flush=True)
          else:
            with open("data.json", "w", encoding="utf-8") as f:
              json.dump(out, f, indent=2, ensure_ascii=False)
            print(f"✅ Wrote {len(out)} rows to data.json.", flush=True)
          PY

      - name: Commit if changed
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "chore(data): MSRC updates (auto)"
          file_pattern: data.json
          commit_user_name: "sundance-bot"
          commit_user_email: "bot@sundancenetworks.com"
