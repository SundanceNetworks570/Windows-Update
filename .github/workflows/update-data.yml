name: Build MSRC updates JSON (daily)

on:
  workflow_dispatch:
  schedule:
    - cron: "0 9 * * *"  # Daily at 9 AM UTC

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests python-dateutil xmltodict

      - name: Build data.json (last 30 days; namespace-agnostic; vuln-level date fallback)
        run: |
          python - << 'PY'
          import json, unicodedata
          from datetime import datetime, timedelta, timezone
          import requests, xmltodict
          from dateutil.parser import isoparse

          NOW = datetime.now(timezone.utc)
          SINCE = NOW - timedelta(days=30)
          CVRF_BASE = "https://api.msrc.microsoft.com/cvrf/v3.0/cvrf"

          # --- Helpers -------------------------------------------------------

          def month_labels(start, end):
            cur = datetime(start.year, start.month, 1, tzinfo=timezone.utc)
            labels = []
            while cur <= end:
              labels.append(cur.strftime("%Y-%b"))
              ny = cur.year + (1 if cur.month == 12 else 0)
              nm = 1 if cur.month == 12 else cur.month + 1
              cur = datetime(ny, nm, 1, tzinfo=timezone.utc)
            return labels

          def clean_bytes(b):
            if not b: return ""
            b = b.replace(b"\xef\xbb\xbf", b"").replace(b"\x00", b"")
            s = b.decode("utf-8", "ignore")
            s = "".join(ch for ch in s if unicodedata.category(ch)[0] != "C" or ch in "\n\r\t")
            if "<html" in s[:400].lower():
              return ""
            return s.strip()

          def get_cvrf_month(label):
            url = f"{CVRF_BASE}/{label}"
            try:
              r = requests.get(url, headers={"Accept": "application/xml"}, timeout=25)
              if r.status_code == 404:
                print(f"⚠️ Skipping {label}: no data available (404)")
                return None
              r.raise_for_status()
              xml = clean_bytes(r.content)
              if not xml:
                print(f"⚠️ Skipping {label}: empty/invalid XML")
                return None
              # Do NOT process namespaces; we’ll match keys by suffix
              return xmltodict.parse(xml, process_namespaces=False)
            except Exception as e:
              print(f"⚠️ Skipping {label}: {e}")
              return None

          def to_utc(dtstr):
            try:
              return isoparse(dtstr).astimezone(timezone.utc)
            except Exception:
              return None

          # Namespace-agnostic recursive search utilities
          def iter_nodes(obj):
            if isinstance(obj, dict):
              for k, v in obj.items():
                yield k, v
                for sub in iter_nodes(v):
                  yield sub
            elif isinstance(obj, list):
              for it in obj:
                for sub in iter_nodes(it):
                  yield sub

          def find_first_text_by_key_suffix(obj, suffixes):
            for k, v in iter_nodes(obj):
              if isinstance(k, str) and any(k.endswith(sfx) for sfx in suffixes):
                if isinstance(v, (str, bytes)):
                  return v
            return None

          def find_all_nodes_by_key_suffix(obj, suffix):
            hits = []
            for k, v in iter_nodes(obj):
              if isinstance(k, str) and k.endswith(suffix):
                hits.append(v)
            return hits

          def doc_date_anywhere(doc, label):
            # 1) CurrentReleaseDate
            cur = find_first_text_by_key_suffix(doc, ["CurrentReleaseDate"])
            dt = to_utc(cur) if cur else None
            if dt:
              print(f"ℹ️ {label}: using CurrentReleaseDate = {dt.date()}")
              return dt

            # 2) Newest date in DocumentTracking -> RevisionHistory -> Revision -> Date
            rev_nodes = find_all_nodes_by_key_suffix(doc, "Revision") or []
            rev_dates = []
            for n in rev_nodes:
              if isinstance(n, dict):
                d = find_first_text_by_key_suffix(n, ["Date"])
                if d:
                  dd = to_utc(d)
                  if dd:
                    rev_dates.append(dd)
            if rev_dates:
              best = max(rev_dates)
              print(f"ℹ️ {label}: using Document RevisionHistory latest = {best.date()}")
              return best

            # 3) InitialReleaseDate
            init = find_first_text_by_key_suffix(doc, ["InitialReleaseDate"])
            idt = to_utc(init) if init else None
            if idt:
              print(f"ℹ️ {label}: using InitialReleaseDate = {idt.date()}")
              return idt

            return None

          def vuln_level_latest_date(doc, label):
            # Find all Vulnerability nodes regardless of prefix
            vulns = []
            for k, v in iter_nodes(doc):
              if isinstance(k, str) and k.endswith("Vulnerability"):
                # xmltodict returns dict for single; keep both dict/list
                if isinstance(v, list):
                  vulns.extend(v)
                elif isinstance(v, dict):
                  vulns.append(v)
            if not vulns:
              return None

            dates = []
            for v in vulns:
              # Look for any RevisionHistory/Revision/Date under the vuln
              revs = find_all_nodes_by_key_suffix(v, "Revision")
              for r in revs:
                if isinstance(r, dict):
                  d = find_first_text_by_key_suffix(r, ["Date"])
                  if d:
                    dd = to_utc(d)
                    if dd:
                      dates.append(dd)
            if dates:
              best = max(dates)
              print(f"ℹ️ {label}: using Vulnerability-level latest revision = {best.date()}")
              return best
            return None

          def extract_cves(doc):
            cves = []
            for k, v in iter_nodes(doc):
              if isinstance(k, str) and k.endswith("Vulnerability"):
                if isinstance(v, list):
                  nodes = v
                elif isinstance(v, dict):
                  nodes = [v]
                else:
                  continue
                for node in nodes:
                  cve = find_first_text_by_key_suffix(node, ["CVE"])
                  if cve:
                    cves.append(cve)
            return list(dict.fromkeys(cves))  # de-dupe preserve order

          # --- Build ----------------------------------------------------------

          rows = []
          labels = month_labels(SINCE, NOW)

          for label in labels:
            doc = get_cvrf_month(label)
            if not doc:
              continue

            dt = doc_date_anywhere(doc, label)
            if not dt:
              # Fallback to vuln-level latest revision date
              dt = vuln_level_latest_date(doc, label)

            if not dt:
              print(f"⚠️ {label}: no usable document date found (doc/vuln); skipping")
              continue

            if not (SINCE <= dt <= NOW):
              print(f"ℹ️ {label}: chosen date {dt.date()} outside window")
              continue

            cves = extract_cves(doc)
            if not cves:
              print(f"ℹ️ {label}: no CVEs found")
              continue

            for cve in cves:
              rows.append({
                "cve": cve,
                "url": f"https://msrc.microsoft.com/update-guide/vulnerability/{cve}",
                "releaseDate": dt.strftime("%Y-%m-%d"),
                "source": label
              })

          # De-dupe on (CVE, releaseDate)
          out, seen = [], set()
          for r in rows:
            key = (r["cve"], r["releaseDate"])
            if key not in seen:
              seen.add(key)
              out.append(r)

          out.sort(key=lambda x: (x["releaseDate"], x["cve"]), reverse=True)

          with open("data.json", "w", encoding="utf-8") as f:
            json.dump(out, f, ensure_ascii=False, indent=2)

          print(f"✅ Completed. {len(out)} updates written (window {SINCE.date()}–{NOW.date()})")
          PY

      - name: Commit if changed
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "chore(data): daily MSRC data.json update"
          file_pattern: data.json
