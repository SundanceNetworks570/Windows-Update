name: Build MSRC updates JSON (daily)

on:
  workflow_dispatch:
  schedule:
    - cron: "0 9 * * *"  # Daily at 9 AM UTC

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests python-dateutil xmltodict

      - name: Build data.json (last 30 days; skip missing months, never fail)
        run: |
          python - << 'PY'
          import json, re, unicodedata
          from datetime import datetime, timedelta, timezone
          import requests, xmltodict
          from dateutil.parser import isoparse

          NOW = datetime.now(timezone.utc)
          SINCE = NOW - timedelta(days=30)
          CVRF_BASE = "https://api.msrc.microsoft.com/cvrf/v3.0/cvrf"

          def month_labels(start, end):
            """Return labels like 2025-Oct, 2025-Nov covering start..end."""
            cur = datetime(start.year, start.month, 1, tzinfo=timezone.utc)
            labels = []
            while cur <= end:
              labels.append(cur.strftime("%Y-%b"))
              ny = cur.year + (1 if cur.month == 12 else 0)
              nm = 1 if cur.month == 12 else cur.month + 1
              cur = datetime(ny, nm, 1, tzinfo=timezone.utc)
            return labels

          def clean_bytes(b):
            if not b: return ""
            b = b.replace(b"\xef\xbb\xbf", b"").replace(b"\x00", b"")
            s = b.decode("utf-8", "ignore")
            # strip control chars except whitespace
            s = "".join(ch for ch in s if unicodedata.category(ch)[0] != "C" or ch in "\n\r\t")
            # bail if the payload is an HTML page
            if "<html" in s[:400].lower():
              return ""
            return s.strip()

          def get_cvrf_month(label):
            url = f"{CVRF_BASE}/{label}"
            try:
              r = requests.get(url, headers={"Accept": "application/xml"}, timeout=20)
              if r.status_code == 404:
                print(f"⚠️ Skipping {label}: no data available (404)")
                return None
              r.raise_for_status()
              xml = clean_bytes(r.content)
              if not xml:
                print(f"⚠️ Skipping {label}: empty or invalid XML")
                return None
              return xmltodict.parse(xml)
            except Exception as e:
              print(f"⚠️ Skipping {label}: {e}")
              return None

          def safe_get(d, path, default=None):
            cur = d
            for p in path:
              if not isinstance(cur, dict):
                return default
              cur = cur.get(p)
            return cur or default

          def to_iso(dtstr):
            try:
              return isoparse(dtstr).astimezone(timezone.utc)
            except Exception:
              return None

          rows = []

          for label in month_labels(SINCE, NOW):
            doc = get_cvrf_month(label)
            if not doc:
              continue

            # ---- Correct date for filtering: DocumentTracking/CurrentReleaseDate
            doc_date_str = safe_get(doc, ["cvrfdoc", "cvrf:DocumentTracking", "cvrf:CurrentReleaseDate"])
            doc_date = to_iso(doc_date_str)
            if not doc_date:
              print(f"⚠️ {label}: missing/invalid CurrentReleaseDate")
              continue

            # Only include this month’s vulns if the document release is in the 30-day window
            if not (SINCE <= doc_date <= NOW):
              print(f"ℹ️ {label}: doc date {doc_date.date()} outside window")
              continue

            vulns = safe_get(doc, ["cvrfdoc", "cvrf:Vulnerability"])
            if not vulns:
              continue
            if isinstance(vulns, dict):
              vulns = [vulns]

            for v in vulns:
              cve = safe_get(v, ["cvrf:CVE"])
              if not cve:
                continue
              rows.append({
                "cve": cve,
                "url": f"https://msrc.microsoft.com/update-guide/vulnerability/{cve}",
                "releaseDate": doc_date.strftime("%Y-%m-%d"),
                "source": label
              })

          # de-dupe on CVE + date
          seen = set()
          unique = []
          for r in rows:
            key = (r["cve"], r["releaseDate"])
            if key not in seen:
              seen.add(key)
              unique.append(r)

          unique.sort(key=lambda x: x["releaseDate"], reverse=True)

          with open("data.json", "w", encoding="utf-8") as f:
            json.dump(unique, f, ensure_ascii=False, indent=2)

          print(f"✅ Completed. {len(unique)} updates written (window {SINCE.date()}–{NOW.date()})")
          PY

      - name: Commit if changed
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "chore(data): daily MSRC data.json update"
          file_pattern: data.json
